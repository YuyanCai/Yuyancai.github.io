---
title: B+树索引的使用
---

# Mysql的数据目录

## 数据库和文件系统的关系

我们知道像 InnoDB 、 MyISAM 这样的存储引擎都是把表存储在磁盘上的，而操作系统用来管理磁盘的那个东东又 被称为 文件系统 ，所以用专业一点的话来表述就是：**像 InnoDB 、 MyISAM 这样的存储引擎都是把表存储在文 件系统上的。**

## MySQL数据目录

MySQL服务器程序在启动时会到文件系统的某个目录下加载一些文件，之后在运行过程中产生的数据也都会存储 到这个目录下的某些文件中，这个目录就称为 数据目录

### 数据目录和安装目录的区别

我们之前只接触过 MySQL 的安装目录（在安装 MySQL 的时候我们可以自己指定），我们重点强调过这个 安装目 录 下非常重要的 bin 目录，它里边存储了许多关于控制客户端程序和服务器程序的命令（许多可执行文件，比 如 mysql ， mysqld ， mysqld_safe 等等等等好几十个）。而 数据目录 是用来存储 MySQL 在运行过程中产生的 数据，一定要和本章要讨论的 安装目录 区别开！一定要区分开！一定要区分开！一定要区分开！

### 如何确定MySQL中的数据目录

到底 MySQL 把数据都存到哪个路径下呢？其实 数据目录 对应着一个系统变量 datadir ，我们在使 用客户端与服务器建立连接之后查看这个系统变量的值就可以了

![image-20220911194025234](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220911194025234.png)



```shell
root@fa82ad6e3052:/var/lib/mysql# ls
'#ib_16384_0.dblwr'   binlog.000004   ca-key.pem        ib_buffer_pool	 mysql		      server-cert.pem
'#ib_16384_1.dblwr'   binlog.000005   ca.pem	        ib_logfile0	 mysql.ibd	      server-key.pem
'#innodb_temp'	      binlog.000006   client-cert.pem   ib_logfile1	 performance_schema   sys
 atguigudb	      binlog.000007   client-key.pem    ibdata1		 private_key.pem      undo_001
 auto.cnf	      binlog.index    dbtest2	        ibtmp1		 public_key.pem       undo_002
```



## 数据目录的结构

MySQL 在运行过程中都会产生哪些数据呢？当然会包含我们创建的数据库、表、视图和触发器吧啦吧啦的用户数 据，除了这些用户数据，为了程序更好的运行， MySQL 也会创建一些其他的额外数据，我们接下来细细的品味一 下这个 数据目录 下的内容。

### 数据库在文件系统中的表示

每当我们使用 CREATE DATABASE 数据库名 语句创建一个数据库的时候，在文件系统上实际发生了什么呢？其实 很简单，**每个数据库都对应数据目录下的一个子目录，或者说对应一个文件夹**，我们每当我们新建一个数据库时， MySQL 会帮我们做这两件事儿：

1. 在 数据目录 下创建一个和数据库名同名的子目录（或者说是文件夹）。

2. 在该与数据库名同名的子目录下创建一个名为 db.opt 的文件，这个文件中包含了该数据库的各种属性，比方说该数据库的字符集和比较规则是个啥。

比方说我们查看一下**在我的计算机上**当前有哪些数据库：

```shell
root@fa82ad6e3052:/var/lib/mysql# ls -l
total 195040
-rw-r-----. 1 mysql mysql   196608 Sep  5 16:29 '#ib_16384_0.dblwr'
-rw-r-----. 1 mysql mysql  8585216 Aug 16 14:50 '#ib_16384_1.dblwr'
drwxr-x---. 2 mysql mysql      187 Sep  3 08:18 '#innodb_temp'
drwxr-x---. 2 mysql mysql      189 Aug  7 07:16  atguigudb
-rw-r-----. 1 mysql mysql       56 Aug  2 09:00  auto.cnf
-rw-r-----. 1 mysql mysql    24557 Aug 14 17:35  binlog.000004
-rw-r-----. 1 mysql mysql     5874 Aug 17 10:26  binlog.000005
-rw-r-----. 1 mysql mysql      481 Sep  3 08:18  binlog.000006
-rw-r-----. 1 mysql mysql     2983 Sep  5 16:27  binlog.000007
-rw-r-----. 1 mysql mysql       64 Sep  3 08:18  binlog.index
-rw-------. 1 mysql mysql     1676 Aug  2 09:00  ca-key.pem
-rw-r--r--. 1 mysql mysql     1112 Aug  2 09:00  ca.pem
-rw-r--r--. 1 mysql mysql     1112 Aug  2 09:00  client-cert.pem
-rw-------. 1 mysql mysql     1676 Aug  2 09:00  client-key.pem
drwxr-x---. 2 mysql mysql      162 Sep  5 16:27  dbtest2
-rw-r-----. 1 mysql mysql     4030 Aug 17 10:26  ib_buffer_pool
-rw-r-----. 1 mysql mysql 50331648 Sep  5 16:29  ib_logfile0
-rw-r-----. 1 mysql mysql 50331648 Aug  2 09:00  ib_logfile1
-rw-r-----. 1 mysql mysql 12582912 Sep  5 16:27  ibdata1
-rw-r-----. 1 mysql mysql 12582912 Sep  3 08:18  ibtmp1
drwxr-x---. 2 mysql mysql      143 Aug  2 09:00  mysql
-rw-r-----. 1 mysql mysql 31457280 Sep  5 16:27  mysql.ibd
drwxr-x---. 2 mysql mysql     8192 Aug  2 09:00  performance_schema
-rw-------. 1 mysql mysql     1676 Aug  2 09:00  private_key.pem
-rw-r--r--. 1 mysql mysql      452 Aug  2 09:00  public_key.pem
-rw-r--r--. 1 mysql mysql     1112 Aug  2 09:00  server-cert.pem
-rw-------. 1 mysql mysql     1676 Aug  2 09:00  server-key.pem
drwxr-x---. 2 mysql mysql       28 Aug  2 09:00  sys
-rw-r-----. 1 mysql mysql 16777216 Sep  5 16:29  undo_001
-rw-r-----. 1 mysql mysql 16777216 Sep  5 16:27  undo_002
```

### 表在文件系统中的表示

我们的数据其实都是以记录的形式插入到表中的，每个表的信息其实可以分为两种：

1. 表结构的定义

2. 表中的数据

表结构 就是该表的名称是啥，表里边有多少列，每个列的数据类型是啥，有啥约束条件和索引，用的是啥字符 集和比较规则吧啦吧啦的各种信息，这些信息都体现在了我们的建表语句中了。为了保存这些信息， InnoDB 和 MyISAM 这两种存储引擎都在 数据目录 下对应的数据库子目录下创建了一个专门用于描述表结构的文件，文件名 是这样：

表名.frm

比方说我们在 dahaizi 数据库下创建一个名为 test 的表：

```sql
mysql> USE dahaizi;
Database changed
mysql> CREATE TABLE test (
 -> c1 INT
 -> );
Query OK, 0 rows affected (0.03 sec)
```

那在数据库 dahaizi 对应的子目录下就会创建一个名为 test.frm 的用于描述表结构的文件。

#### InnoDB是如何存储表数据的

- InnoDB 其实是使用 页 为基本单位来管理存储空间的，默认的 页 大小为 16KB 。
- 对于 InnoDB 存储引擎来说，每个索引都对应着一棵 B+ 树，该 B+ 树的每个节点都是一个数据页，数据页之间不必要是物理连续的，因为数据页之间有 双向链表 来维护着这些页的顺序。
- InnoDB 的聚簇索引的叶子节点存储了完整的用户记录，也就是所谓的索引即数据，数据即索引。

为了更好的管理这些页，设计 InnoDB 的大叔们提出了一个 `表空间` 或者 `文件空间 `（英文名： table space 或 者 file space ）的概念，这个表空间是一个抽象的概念，它可以对应文件系统上一个或多个真实文件（不同表 空间对应的文件数量可能不同）。每一个 `表空间 `可以被划分为很多很多很多个 页 ，我们的表数据就存放在某 个 表空间 下的某些页里。设计 InnoDB 的大叔将表空间划分为几种不同的类型，我们一个一个看一下。

**系统表空间（system tablespace）**

这个所谓的` 系统表空间 `可以对应文件系统上一个或多个实际的文件，默认情况下， InnoDB 会在 数据目录 下创 建一个名为` ibdata1 `（在你的数据目录下找找看有木有）、大小为 12M 的文件，这个文件就是对应的 `系统表空 间 `在文件系统上的表示



如果你想让系统表空间对应文件系统上多个实际文件，或者仅仅觉得原来的 ibdata1 这个文件名难听，那 可以在 MySQL 启动时配置对应的文件路径以及它们的大小，比如我们这样修改一下配置文件：

```sql
[server]
innodb_data_file_path=data1:512M;data2:512M:autoextend
```

这样在 MySQL 启动之后就会创建这两个512M大小的文件作为 系统表空间 ，其中的 autoextend 表明这两个文件 如果不够用会自动扩展 data2 文件的大小。

系统表空间只有一份。从MySQL5.5.7到MySQL5.6.6之间的各个版 本中，我们表中的数据都会被默认存储到这个 **系统表空间。**

**独立表空间(file-per-table tablespace)**

在MySQL5.6.6以及之后的版本中，` InnoDB `并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表 建立一个`独立表空间`，也就是说我们创建了多少个表，就有多少个独立表空间。使用 独立表空间 来存储表数据 的话，会在该表所属数据库对应的子目录下创建一个表示该 独立表空间 的文件，文件名和表名相同，只不过添 加了一个 .ibd 的扩展名而已，所以完整的文件名称长这样：

表名.ibd

比方说假如我们使用了 独立表空间 去存储 xiaohaizi 数据库下的 test 表的话，那么在该表所在数据库对应的 xiaohaizi 目录下会为 test 表创建这两个文件：

test.frm 

test.ibd

其中 test.ibd 文件就用来存储 test 表中的数据和索引。当然我们也可以自己指定使用 系统表空间 还是 独立 表空间 来存储数据，这个功能由启动参数 innodb_file_per_table 控制，比如说我们想刻意将表数据都存储到 系统表空间 时，可以在启动 MySQL 服务器的时候这样配置：

```
[server]
innodb_file_per_table=0
```

当 innodb_file_per_table 的值为 0 时，代表使用系统表空间；当 innodb_file_per_table 的值为 1 时，代表 使用独立表空间。不过 innodb_file_per_table 参数只对新建的表起作用，对于已经分配了表空间的表并不起作 用。如果我们想把已经存在系统表空间中的表转移到独立表空间，可以使用下边的语法：

```
ALTER TABLE 表名 TABLESPACE [=] innodb_file_per_table;
```

或者把已经存在独立表空间的表转移到系统表空间，可以使用下边的语法：

```
ALTER TABLE 表名 TABLESPACE [=] innodb_system;
```

其中中括号扩起来的 = 可有可无，比方说我们想把 test 表从独立表空间移动到系统表空间，可以这么写：

```
ALTER TABLE test TABLESPACE innodb_system;
```

**其他类型的表空间**

随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间 （general tablespace）、`undo表空间`（undo tablespace）、`临时表空间`（temporary tablespace）吧啦吧啦 的，具体情况我们就不细唠叨了，等用到的时候再提。

#### MyISAM是如何存储表数据的

我们知道不像 InnoDB 的索引和数据 是一个东东，在 MyISAM 中的索引全部都是 二级索引 ，该存储引擎的数据和索引是分开存放的。所以在文件系统 中也是使用不同的文件来存储数据文件和索引文件。而且和 InnoDB 不同的是， MyISAM 并没有什么所谓的 表空 间 一说，表数据都存放到对应的数据库子目录下。假如 test 表使用 MyISAM 存储引擎的话，那么在它所在数据 库对应的 xiaohaizi 目录下会为 test 表创建这三个文件：

```
test.frm
test.MYD
test.MYI
```

其中 `test.MYD`代表表的数据文件，也就是我们插入的用户记录；` test.MYI `代表表的索引文件，我们为该表创建 的索引都会放到这个文件中。

### 视图在文件系统中的表示

我们知道 MySQL 中的视图其实是虚拟的表，也就是某个查询语句的一个别名而已，所以在存储 视图 的时候是不 需要存储真实的数据的，只需要把它的结构存储起来就行了。和 表 一样，描述视图结构的文件也会被存储到所 属数据库对应的子目录下边，只会存储一个 视图名.frm 的文件。

### 其他的文件

除了我们上边说的这些用户自己存储的数据以外， 数据目录 下还包括为了更好运行程序的一些额外文件，主要 包括这几种类型的文件：

- 服务器进程文件。

我们知道每运行一个 MySQL 服务器程序，都意味着启动一个进程。 MySQL 服务器会把自己的进程ID写入到一个文件中。

- 服务器日志文件。

在服务器运行过程中，会产生各种各样的日志，比如常规的查询日志、错误日志、二进制日志、redo日志吧啦吧啦各种日志，这些日志各有各的用途，我们之后会重点唠叨各种日志的用途，现在先了解一下就可以了。

- 默认/自动生成的SSL和RSA证书和密钥文件。

主要是为了客户端和服务器安全通信而创建的一些文件

## 文件系统对数据库的影响

因为 MySQL 的数据都是存在文件系统中的，就不得不受到文件系统的一些制约，这在数据库和表的命名、表的大 小和性能方面体现的比较明显，比如下边这些方面：

- 数据库名称和表名称不得超过文件系统所允许的最大长度。

每个数据库都对应 数据目录 的一个子目录，数据库名称就是这个子目录的名称；每个表都会在数据库子目 录下产生一个和表名同名的 .frm 文件，如果是 InnoDB 的独立表空间或者使用 MyISAM 引擎还会有别的文件 的名称与表名一致。这些目录或文件名的长度都受限于文件系统所允许的长度～

- 特殊字符的问题

为了避免因为数据库名和表名出现某些特殊字符而造成文件系统不支持的情况， MySQL 会把数据库名和表名 中所有除数字和拉丁字母以外的所有字符在文件名里都映射成 @+编码值 的形式作为文件名。比方说我们创 建的表的名称为 'test?' ，由于 ? 不属于数字或者拉丁字母，所以会被映射成编码值，所以这个表对应 的 .frm 文件的名称就变成了 test@003f.frm 。

- 文件长度受文件系统最大长度限制

对于 InnoDB 的独立表空间来说，每个表的数据都会被存储到一个与表名同名的 .ibd 文件中；对于 MyISAM 存储引擎来说，数据和索引会分别存放到与表同名的 .MYD 和 .MYI 文件中。这些文件会随着表中记录的增加 而增大，它们的大小受限于文件系统支持的最大文件大小。

## MySQL系统数据库简介

- mysql

这个数据库贼核心，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过 程中产生的日志信息，一些帮助信息以及时区信息等。

- information_schema

这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引吧啦吧啦。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为元数据。

- performance_schema

这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。

- sys

这个数据库主要是通过视图的形式把 information_schema 和 performance_schema 结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。

# 六、InnoDB的表空间

`表空间 `是一个抽象的概念，对于系统表空间来说，对应着文件系统中一个或多个 实际文件；对于每个独立表空间来说，对应着文件系统中一个名为 `名.ibd `的实际文件。大家可以把表空间想 象成被切分为许许多多个` 页 `的池子，当我们想为某个表插入一条记录的时候，就从池子中捞出一个对应的页来 把数据写进去。

##  回忆一些旧知识

###  页面类型

**InnoDB是以页为单位管理存储空间的**，我们的聚簇索引（也就是完整的表数据）和其他的二级索引 都是以` B+ `树的形式保存到表空间的，而` B+` 树的节点就是数据页。我们前边说过，这个数据页的类型名其实 是：` FIL_PAGE_INDEX `，除了这种存放索引数据的页面类型之外，InnoDB也为了不同的目的设计了若干种不同类 型的页面

![image-20220911203246593](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220911203246593.png)

因为页面类型前边都有个 FIL_PAGE 或者 FIL_PAGE_TYPE 的前缀，为简便起见我们后边唠叨页面类型的时候就把 这些前缀省略掉了，比方说 FIL_PAGE_TYPE_ALLOCATED 类型称为 ALLOCATED 类型， FIL_PAGE_INDEX 类型称为 INDEX 类型。

### 页面通用部分

我们前边说过数据页，也就是 `INDEX `类型的页由7个部分组成，其中的两个部分是所有类型的页面都通用的。当

![image-20220911203438692](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220911203438692.png)

从上图中可以看出，任何类型的页都会包含这两个部分：

- File Header ：记录页面的一些通用信息 
- File Trailer ：校验页是否完整，**保证从内存到磁盘刷新时内容的一致性。**

File Header各组成部分如下：

![](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220906170444968.png)

## 独立表空间结构

### 区（extent）的概念

表空间中的页实在是太多了，为了更好的管理这些页面，设计 InnoDB 的大叔们提出了 区 （英文名： extent ） 的概念。对于16KB的页来说，连续的64个页就是一个 区 ，也就是说一个区默认占用1MB空间大小。不论是系统 表空间还是独立表空间，都可以看成是由若干个区组成的，每256个区被划分成一组。画个图表示就是这样：

![image-20220912095948198](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220912095948198.png)

其中 extent 0 ~ extent 255 这256个区算是第一个组， extent 256 ~ extent 511 这256个区算是第二个 组， extent 512 ~ extent 767 这256个区算是第三个组（上图中并未画全第三个组全部的区，请自行脑补）， 依此类推可以划分更多的组。这些组的头几个页面的类型都是类似的，就像这样：

![image-20220912100043038](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220912100043038.png)

从上图中我们能得到如下信息：

- **第一个组最开始的3个页面的类型是固定的**，也就是说 extent 0 这个区最开始的3个页面的类型是固定的， 分别是：
  - `FSP_HDR `类型：这个类型的页面是用来登记整个表空间的一些整体属性以及本组所有的 区 ，也就是extent 0 ~ extent 255 这256个区的属性，稍后详细唠叨。需要注意的一点是，整个表空间只有一个 FSP_HDR 类型的页面。
  - `IBUF_BITMAP `类型：这个类型的页面是存储本组所有的区的所有页面关于 INSERT BUFFER 的信息。当然，你现在不用知道啥是个 INSERT BUFFER ，后边会详细说到你吐。
  - `INODE `类型：这个类型的页面存储了许多称为 INODE 的数据结构，还是那句话，现在你不需要知道啥是个 INODE ，后边儿会说到你吐。
- **其余各组最开始的2个页面的类型是固定的**，也就是说` extent 256 `、 `extent 512 `这些区最开始的2个页面 的类型是固定的，分别是：
  - `XDES `类型：全称是 extent descriptor ，用来登记本组256个区的属性，也就是说对于在 extent 256区中的该类型页面存储的就是 extent 256 ~ extent 511 这些区的属性，对于在 extent 512 区中的该类型页面存储的就是 extent 512 ~ extent 767 这些区的属性。上边介绍的 FSP_HDR 类型的页面其实和 XDES 类型的页面的作用类似，只不过 FSP_HDR 类型的页面还会额外存储一些表空间的属性。
  - `IBUF_BITMAP `类型：上边介绍过了。

总结：**表空间被划分为许多连续的 区 ，每个区默认由64个页组成，每256个区划分为一组，每个组的最开始的几个页面类型是固定的就好了**

###  段（segment）的概念

为啥好端端的提出一个 `区 （ extent ）`的概念呢？我们以前分析问题的套路都是这样的：表中的记录存储到页里 边儿，然后页作为节点组成 `B+` 树，这个` B+ `树就是索引，然后吧啦吧啦一堆聚簇索引和二级索引的区别。这套路 也没啥不妥的呀～

是的，如果我们表中数据量很少的话，比如说你的表中只有几十条、几百条数据的话，的确用不到 区 的概念， 因为简单的几个页就能把对应的数据存储起来，但是你架不住表里的记录越来越多呀。

？？啥？？表里的记录多了又怎样？ B+ 树的每一层中的页都会形成一个双向链表呀， File Header 中的 FIL_PAGE_PREV 和 FIL_PAGE_NEXT 字段不就是为了形成双向链表设置的么？

 是的是的，您说的都对，从理论上说，不引入 区 的概念只使用 页 的概念对存储引擎的运行并没啥影响，但是我 们来考虑一下下边这个场景：

- 我们每向表中插入一条记录，本质上就是向该表的聚簇索引以及所有二级索引代表的 B+ 树的节点中插入数 据。而 B+ 树的每一层中的页都会形成一个双向链表，如果是以` 页 `为单位来分配存储空间的话，**双向链表相 邻的两个页之间的物理位置可能离得非常远**。我们介绍 B+ 树索引的适用场景的时候特别提到范围查询只需 要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页 物理位置离得非常远，就是所谓的` 随机I/O `。再一次强调，磁盘的速度和内存的速度差了好几个数量级，` 随 机I/O `是非常慢的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可 以使用所谓的` 顺序I/O` 。

所以，所以，所以才引入了`区 （ extent ）`的概念，一个区就是在物理位置上连续的64个页。在表中数据量大 的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照 区 为单位分配，甚至在表中的数据 十分非常特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足填充满整个 区），但是从性能角度看，可以消除很多的`随机 I/O` ，功大于过嘛！

事情到这里就结束了么？太天真了，我们提到的范围查询，其实是对 B+ 树叶子节点中的记录进行顺序扫描，而 如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打 折扣了。所以设计 InnoDB 的大叔们对 B+ 树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己 独有的 区 ，非叶子节点也有自己独有的 区 。**存放叶子节点的区的集合**就算是一个` 段 （ segment ）`，**存放非叶 子节点的区的集合**也算是一个 `段` 。也就是说**一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。**

默认情况下一个使用 InnoDB 存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存 储空间的，一个区默认占用1M存储空间，所以默认情况下一个只存了几条记录的小表也需要2M的存储空间么？ 以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。现在的问题是我们前面介绍的区都是很`纯粹`的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在 的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。现在为了考虑以完整的区为单位分配 给某个段对于数据量较小的表太浪费存储空间的这种情况，设计 InnoDB 的大叔们提出了一个`碎片（fragment） 区`的概念，也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页 可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空 间，并不属于任何一个段。所以此后为某个段分配存储空间的策略是这样的：

- 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。
- 当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。

所以现在`段不能仅定义为是某些区的集合`，更精确的应该是**某些零散的页面以及一些完整的区的集合。**除了索引 的叶子节点段和非叶子节点段之外， `InnoDB `中还有为存储一些特殊的数据而定义的段，比如回滚段，当然我们 现在并不关心别的类型的段，现在只需要知道段是一些零散的页面以及一些完整的区的集合就好了。

### 区的分类

表空间的是由若干个区组成的，这些区大体上可以分为4种类型:

- 空闲的区：现在还没有用到这个区中的任何页面。
- 有剩余空间的碎片区：表示碎片区中还有可用的页面。 
- 没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。 
- 附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些 特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。

这4种类型的区也可以被称为区的4种状态（ State ），设计 InnoDB 的大叔们为这4种状态的区定义了特定的名 词儿：

状态名 					含义
FREE 						 空闲的区
FREE_FRAG 		   有剩余空间的碎片区
FULL_FRAG 			没有剩余空间的碎片区
FSEG 						 附属于某个段的区

需要再次强调一遍的是，处于 FREE 、 FREE_FRAG 以及 FULL_FRAG 这三种状态的区都是独立的，算是直属于表空 间；而处于 FSEG 状态的区是附属于某个段的。

> 如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像 是处于`FSEG`的区全都隶属于某个段，而处于`FREE`、`FREE_FRAG`以及`FULL_FRAG`这三种状态的区却 直接隶属于表空间，就像独立团直接听命于军部一样。

为了方便管理这些区，设计 InnoDB 的大叔设计了一个称为 XDES Entry 的结构（全称就是Extent Descriptor Entry），每一个区都对应着一个 XDES Entry 结构，这个结构记录了对应的区的一些属性。我们先看图来对这个 结构有个大致的了解：

![image-20220914103010518](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220914103010518.png)

# 七、单表访问方法

## 访问方法

MySQL的大叔把查询的执行方式大致分 为下边两种：

- 使用全表扫描进行查询 

这种执行方式很好理解，就是把表的每一行记录都扫一遍嘛，把符合搜索条件的记录加入到结果集就完了。 不管是啥查询都可以使用这种方式执行，当然，这种也是最笨的执行方式。

- 使用索引进行查询

因为直接使用全表扫描的方式执行查询要遍历好多记录，所以代价可能太大了。如果查询语句中的搜索条件 可以使用到某个索引，那直接使用索引来执行查询可能会加快查询执行的时间。使用索引来执行查询的方式 五花八门，又可以细分为许多种类：

- 针对主键或唯一二级索引的等值查询
- 针对普通二级索引的等值查询
- 针对索引列的范围查询
- 直接扫描整个索引

## const

有的时候我们可以通过主键列来定位一条记录，比方说这个查询

```
SELECT * FROM single_table WHERE id = 1438;
```

MySQL 会直接利用主键值在聚簇索引中定位对应的用户记录，就像这样：

![image-20220917152902573](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220917152902573.png)

类似的，我们根据唯一二级索引列来定位一条记录的速度也是贼快 的，比如下边这个查询：

SELECT * FROM single_table WHERE key2 = 3841

这个查询的执行过程的示意图就是这样

![image-20220917152942957](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220917152942957.png)

可以看到这个查询的执行分两步，第一步先从 idx_key2 对应的 B+ 树索引中根据 key2 列与常数的等值比较条件 定位到一条二级索引记录，然后再根据该记录的 id 值到聚簇索引中获取到完整的用户记录。

设计 MySQL 的大叔认为通过主键或者唯一二级索引列与常数的等值比较来定位一条记录是像坐火箭一样快的，所 以他们把这种通过主键或者**唯一二级索引**列来定位一条记录的访问方法定义为： const ，意思是常数级别的，代 价是可以忽略不计的。不过这种 const 访问方法只能在主键列或者唯一二级索引列和一个常数进行等值比较时才 有效，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，这个 const 访问方法才有效（这是因为只有该索引中全部列都采用等值比较才可以定位唯一的一条记录）。

对于**唯一二级索引来**说，查询该列为 NULL 值的情况比较特殊，比如这样：

SELECT * FROM single_table WHERE key2 IS NULL;

因为**唯一二级索引**列并不限制 NULL 值的数量，所以上述语句可能访问到多条记录，也就是说 上边这个语句不可 以使用 const 访问方法来执行（至于是什么访问方法我们下边马上说）。

## ref

有时候我们对某个普通的二级索引列与常数进行等值比较，比如这样：

```sql
SELECT * FROM single_table WHERE key1 = 'abc';
```

对于这个查询，我们当然可以选择全表扫描来逐一对比搜索条件是否满足要求，我们也可以先使用二级索引找到 对应记录的`id` 值，然后再回表到聚簇索引中查找完整的用户记录。由于普通二级索引并不限制索引列值的唯一 性，所以可能找到多条对应的记录，也就是说使用二级索引来执行查询的代价取决于等值匹配到的二级索引记录 条数。如果匹配的记录较少，则回表的代价还是比较低的，所以 MySQL 可能选择使用索引而不是全表扫描的方式 来执行查询。设计 MySQL 的大叔就把这种搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访 问方法称为： ref 。我们看一下采用 ref 访问方法执行查询的图示：

![image-20220917194905611](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220917194905611.png)

- 二级索引列值为 NULL 的情况

不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含 NULL 值的数量并不限制，所以我们采用 key IS NULL 这种形式的搜索条件最多只能使用 ref 的访问方法，而不是 const 的访问方法。

- 对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就可能采用 ref 的访问方法，比方说下边这几个查询：

```sql
SELECT * FROM single_table WHERE key_part1 = 'god like';
SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary';
SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary' AND key_part3 = 'penta kill';
```

但是如果最左边的连续索引列并不全部是等值比较的话，它的访问方法就不能称为 ref 了，比方说这样：

```sql
SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 > 'legendary';
```

## ref_or_null

有时候我们不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为 NULL 的记录也找出 来，就像下边这个查询：

```sql
SELECT * FROM single_demo WHERE key1 = 'abc' OR key1 IS NULL;
```

当使用二级索引而不是全表扫描的方式执行该查询时，这种类型的查询使用的访问方法就称为 ref_or_null ，这个 ref_or_null 访问方法的执行过程如下：

![image-20220917195507409](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220917195507409.png)

可以看到，上边的查询相当于先分别从 idx_key1 索引对应的 B+ 树中找出 key1 IS NULL 和 key1 = 'abc' 的两 个连续的记录范围，然后根据这些二级索引记录中的 id 值再回表查找完整的用户记录。

## range

我们之前介绍的几种访问方法都是在对索引列与某一个常数进行等值比较的时候才可能使用到（ ref_or_null 比 较奇特，还计算了值为 NULL 的情况），但是有时候我们面对的搜索条件更复杂，比如下边这个查询：

```sql
SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 >= 38 AND key2 <= 79);
```

我们当然还可以使用全表扫描的方式来执行这个查询，不过也可以使用 二级索引 + 回表 的方式执行，如果采 用 二级索引 + 回表 的方式来执行的话，那么此时的搜索条件就不只是要求索引列与常数的等值匹配了，而是索 引列需要匹配某个或某些范围的值，在本查询中 key2 列的值只要匹配下列3个范围中的任何一个就算是匹配成功 了：

```text
key2 的值是 1438
key2 的值是 6328
key2 的值在 38 和 79 之间。
```

设计 MySQL 的大叔把这种利用索引进行范围匹配的访问方法称之为： range 。

> 此处所说的使用索引进行范围匹配中的 `索引` 可以是聚簇索引，也可以是二级索引。

如果把这几个所谓的 key2 列的值需要满足的 范围 在数轴上体现出来的话，那应该是这个样子：

![image-20220917195722426](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220917195722426.png)

也就是从数学的角度看，每一个所谓的范围都是数轴上的一个 区间 ，3个范围也就对应着3个区间：

- 范围1： key2 = 1438 
- 范围2： key2 = 6328 
- 范围3： key2 ∈ [38, 79] ，注意这里是闭区间。

我们可以把那种索引列等值匹配的情况称之为 `单点区间 `，上边所说的 `范围1 `和` 范围2 `都可以被称为单点区间， 像`范围3 `这种的我们可以称为连续范围区间。

## index

看下边这个查询：

```sql
SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';
```

由于 key_part2 并不是联合索引 idx_key_part 最左索引列，所以我们无法使用 ref 或者 range 访问方法来执行 这个语句。但是这个查询符合下边这两个条件：

- 它的查询列表只有3个列： key_part1 , key_part2 , key_part3 ，而索引 idx_key_part 又包含这三个列。
- 搜索条件中只有 key_part2 列。这个列也包含在索引 idx_key_part 中。 

也就是说我们可以直接通过**遍历** `idx_key_part` **索引的叶子节点的记录来比较** `key_part2 = 'abc'`这个条件是否成立，把匹配成功的二级索引记录的 `key_part1 , key_part2 , key_part3` 列的值直接加到结果集中就行了。由 于二级索引记录比聚簇索记录小的多（聚簇索引记录要存储所有用户定义的列以及所谓的隐藏列，而二级索引记 录只需要存放索引列和主键），而且这个过程也不用进行回表操作，所以直接遍历二级索引比直接遍历聚簇索引 的成本要小很多，设计 MySQL 的大叔就把这种采用遍历二级索引记录的执行方式称之为：` index` 。

## all

最直接的查询执行方式就是我们已经提了无数遍的全表扫描，对于 InnoDB 表来说也就是直接扫描聚簇索引，设 计 MySQL 的大叔把这种使用全表扫描执行查询的方式称之为： all 



# 八、两个表的亲密接触-连接的原理

搞数据库一个避不开的概念就是 Join ，翻译成中文就是 连接 。相信很多小伙伴在初学连接的时候有些一脸懵 逼，理解了连接的语义之后又可能不明白各个表中的记录到底是怎么连起来的，以至于在使用的时候常常陷入下 边两种误区

- 误区一：业务至上，管他三七二十一，再复杂的查询也用在一个连接语句中搞定。 
- 误区二：敬而远之，上次 DBA 那给报过来的慢查询就是因为使用了连接导致的，以后再也不敢用了

## 连接简介

### 连接的本质

`连接 `的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。所以我们把 t1 和 t2 两个表连接起来的过程如下图所示：

![image-20220918221810957](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220918221810957.png)

这个过程看起来就是把` t1 `表的记录和` t2 `的记录连起来组成新的更大的记录，所以这个查询过程称之为连接查 询。连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，像这样的结果 集就可以称之为 `笛卡尔积 `。因为表 t1 中有3条记录，表 t2 中也有3条记录，所以这两个表连接之后的笛卡尔积 就有 3×3=9 行记录。连接查询的语法也很随意，只要在 FROM 语句后边跟多个表名就好了，比如 我们把 t1 表和 t2 表连接起来的查询语句可以写成这样：

```sql
mysql> SELECT * FROM t1, t2;
+------+------+------+------+
| m1 | n1 | m2 | n2 |
+------+------+------+------+
| 1 | a | 2 | b |
| 2 | b | 2 | b |
| 3 | c | 2 | b |
| 1 | a | 3 | c |
| 2 | b | 3 | c |
| 3 | c | 3 | c |
| 1 | a | 4 | d |
| 2 | b | 4 | d |
| 3 | c | 4 | d |
+------+------+------+------+
9 rows in set (0.00 sec)
```

### 连接过程简介

如果我们乐意，我们可以连接任意数量张表，但是如果没有任何限制条件的话，这些表连接起来产生的 笛卡尔 积 可能是非常巨大的。比方说3个100行记录的表连接起来产生的 笛卡尔积 就有 100×100×100=1000000 行数 据！所以在连接的时候过滤掉特定记录组合是有必要的，在连接**查询中的过滤**条件可以分成两种：

- **涉及单表的条件**

这种只设计单表的过滤条件我们之前都提到过一万遍了，我们之前也一直称为 搜索条件 ，比如` t1.m1 > 1` 是只针对 t1 表的过滤条件，` t2.n2 < 'd' `是只针对 t2 表的过滤条件。

- **涉及两表的条件**

这种过滤条件我们之前没见过，比如` t1.m1 = t2.m2 、 t1.n1 > t2.n2 `等，这些条件中涉及到了两个表，我 们稍后会仔细分析这种过滤条件是如何使用的哈。

下边我们就要看一下携带过滤条件的连接查询的大致执行过程了，比方说下边这个查询语句：

SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';

在这个查询中我们指明了这三个过滤条件：

- t1.m1 > 1
- t1.m1 = t2.m2
- t2.n2 < 'd'

那么这个连接查询的大致执行过程如下：

1. 首先确定第一个需要查询的表，这个表称之为 `驱动表` 。怎样在单表中执行查询语句我们在前一章都唠叨过 了，只需要选取代价最小的那种访问方法去执行单表查询语句就好了（就是说从const、ref、ref_or_null、 range、index、all这些执行方法中选取代价最小的去执行查询）。此处假设使用 t1 作为驱动表，那么就需 要到 t1 表中找满足` t1.m1 > 1 `的记录，因为表中的数据太少，我们也没在表上建立二级索引，所以此处查 询 t1 表的访问方法就设定为 `all `吧，也就是采用全表扫描的方式执行单表查询。关于如何提升连接查询的 性能我们之后再说，现在先把基本概念捋清楚哈。所以查询过程就如下图所示：

![image-20220918222431262](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220918222431262.png)

我们可以看到， t1 表中符合 t1.m1 > 1 的记录有两条。

2. 针对上一步骤中从驱动表产生的结果集中的每一条记录，分别需要到 t2 表中查找匹配的记录，所谓` 匹配的 记录` ，指的是符合过滤条件的记录。因为是根据 t1 表中的记录去找 t2 表中的记录，所以 t2 表也可以被 称之为 `被驱动表` 。上一步骤从驱动表中得到了2条记录，所以需要查询2次 t2 表。此时涉及两个表的列的 过滤条件 `t1.m1 = t2.m2 `就派上用场了：

- 当 t1.m1 = 2 时，过滤条件 t1.m1 = t2.m2 就相当于 t2.m2 = 2 ，所以此时 t2 表相当于有了 t2.m2 = 2 、 t2.n2 < 'd' 这两个过滤条件，然后到 t2 表中执行单表查询。
- 当 t1.m1 = 3 时，过滤条件 t1.m1 = t2.m2 就相当于 t2.m2 = 3 ，所以此时 t2 表相当于有了 t2.m2 =3 、 t2.n2 < 'd' 这两个过滤条件，然后到 t2 表中执行单表查询。

所以整个连接查询的执行过程就如下图所示：

![image-20220918223634991](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220918223634991.png)

也就是说整个连接查询最后的结果只有两条符合过滤条件的记录：

```sql
+------+------+------+------+
| m1 | n1 | m2 | n2 |
+------+------+------+------+
| 2 | b | 2 | b |
| 3 | c | 3 | c |
+------+------+------+------+
```

从上边两个步骤可以看出来，我们上边唠叨的这个两表连接查询共需要查询1次 t1 表，2次 t2 表。当然这是在 特定的过滤条件下的结果，如果我们把` t1.m1 > 1` 这个条件去掉，那么从 t1 表中查出的记录就有3条，就需要 查询3次 t2 表了。也就是说在两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。

### 内连接和外连接

我们要如下两张表

![image-20220918231131038](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220918231131038.png)

现在我们想把每个学生的考试成绩都查询出来就需要进行两表连接了（因为 score 中没有姓名信息，所以不能单 纯只查询 score 表）。连接过程就是从 student 表中取出记录，在 score 表中查找 number 相同的成绩记录，所 以过滤条件就是 student.number = socre.number ，整个查询语句就是这样：

```sql
mysql> SELECT s1.number, s1.name, s2.subject, s2.score FROM student AS s1, score AS s2 WHE
RE s1.number = s2.number;
+----------+-----------+-----------------------------+-------+
| number | name | subject | score |
+----------+-----------+-----------------------------+-------+
| 20180101 | 杜子腾 | 母猪的产后护理 | 78 |
| 20180101 | 杜子腾 | 论萨达姆的战争准备 | 88 |
| 20180102 | 范统 | 论萨达姆的战争准备 | 98 |
| 20180102 | 范统 | 母猪的产后护理 | 100 |
+----------+-----------+-----------------------------+-------+
4 rows in set (0.00 sec)
```

从上述查询结果中我们可以看到，各个同学对应的各科成绩就都被查出来了，可是有个问题， 史珍香 同学，也 就是学号为 20180103 的同学因为某些原因没有参加考试，所以在 score 表中没有对应的成绩记录。那如果老师 想查看所有同学的考试成绩，即使是缺考的同学也应该展示出来，但是到目前为止我们介绍的 连接查询 是无法 完成这样的需求的。我们稍微思考一下这个需求，其本质是想：`驱动表中的记录即使在被驱动表中没有匹配的记 录，也仍然需要加入到结果集`。为了解决这个问题，就有了 `内连接` 和 `外连接` 的概念：

- 对于 `内连接 `的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果 集，我们上边提到的连接都是所谓的 内连接 。
- 对于 `外连接 `的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。

在 MySQL 中，根据选取驱动表的不同，外连接仍然可以细分为2种：

- 左外连接

选取左侧的表为驱动表

- 右外连接

选取右侧的表为驱动表

即使对于外连接来说，有时候我们也并不想把驱动表的全部记录都加入到最后的结果 集。这就犯难了，有时候匹配失败要加入结果集，有时候又不要加入结果集，这咋办，有点儿愁啊。。。噫，把 过滤条件分为两种不就解决了这个问题了么，所以放在不同地方的过滤条件是有不同语义的：

- `WHERE` 子句中的过滤条件

`WHERE` 子句中的过滤条件就是我们平时见的那种，不论是内连接还是外连接，凡是不符合 `WHERE `子句中的过滤条件的记录都不会被加入最后的结果集。

- `ON `子句中的过滤条件

对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配` ON` 子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用` NULL `值填充。

需要注意的是，这个 ON 子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记 录加入结果集这个场景下提出的，所以如果把 ON 子句放到内连接中， MySQL 会把它和 WHERE 子句一样对 待，也就是说：**内连接中的WHERE子句和ON子句是等价的。**

一般情况下，我们都把只涉及单表的过滤条件放到` WHERE `子句中，把涉及两表的过滤条件都放到` ON `子句中，我 们也一般把放到 ON 子句中的过滤条件也称之为 `连接条件` 。

> 小贴士： 左外连接和右外连接简称左连接和右连接，所以下边提到的左外连接和右外连接中的`外`字都用括号扩 起来，以表示这个字儿可有可无。

#### 左（外）连接的语法

左（外）连接的语法还是挺简单的，比如我们要把 t1 表和 t2 表进行左外连接查询可以这么写：

```sql
SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];
```

其中中括号里的 `OUTER `单词是可以省略的。对于` LEFT JOIN `类型的连接来说，我们把放在左边的表称之为外表或 者驱动表，右边的表称之为内表或者被驱动表。所以上述例子中 t1 就是外表或者驱动表， t2 就是内表或者被驱 动表。需要注意的是，**对于左（外）连接和右（外）连接来说，必须使用 ON 子句来指出连接条件。**了解了左 （外）连接的基本语法之后，再次回到我们上边那个现实问题中来，看看怎样写查询语句才能把所有的学生的成 绩信息都查询出来，即使是缺考的考生也应该被放到结果集中：

![image-20220919084237023](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220919084237023.png)

#### 右（外）连接的语法

右（外）连接和左（外）连接的原理是一样一样的，语法也只是把 LEFT 换成 RIGHT 而已：

```sql
SELECT * FROM t1 RIGHT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];
```

只不过驱动表是右边的表，被驱动表是左边的表，具体就不唠叨了。

#### 内连接的语法

内连接和外连接的根本区别就是**在驱动表中的记录不符合 ON 子句中的连接条件时不会把该记录加入到最后的结 果集**，我们最开始唠叨的那些连接查询的类型都是内连接。不过之前仅仅提到了一种最简单的内连接语法，就是 直接把需要连接的多个表都放到 FROM 子句后边。其实针对内连接，MySQL提供了好多不同的语法，我们以 t1 和 t2 表为例瞅瞅：

```sql
SELECT * FROM t1 [INNER | CROSS] JOIN t2 [ON 连接条件] [WHERE 普通过滤条件];
```

也就是说在 MySQL 中，下边这几种内连接的写法都是等价的：

```sql
SELECT * FROM t1 JOIN t2;
SELECT * FROM t1 INNER JOIN t2;
SELECT * FROM t1 CROSS JOIN t2;
```

上边的这些写法和直接把需要连接的表名放到 FROM 语句之后，用逗号 , 分隔开的写法是等价的：

```sql
SELECT * FROM t1, t2;
```

现在我们虽然介绍了很多种 内连接 的书写方式，不过熟悉一种就好了，这里我们推荐 INNER JOIN 的形式书写内 连接（因为 INNER JOIN 语义很明确嘛，可以和 LEFT JOIN 和 RIGHT JOIN 很轻松的区分开）。这里需要注意的 是，由于在**内连接中ON子句和WHERE子句是等价的，所以内连接中不要求强制写明ON子句。**

我们前边说过，**连接的本质**就是`把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户`。不论 哪个表作为驱动表，两表连接产生的笛卡尔积肯定是一样的。

1. 对于内连接来说，由于凡是不符合 ON 子句或 WHERE 子句中的条件的记录都会被过滤掉，其实也就相当于从两表连接的笛卡尔积中把不符合过滤条件的记录给 踢出去，所以对于内连接来说，**驱动表和被驱动表是可以互换的，并不会影响最后的查询结果**
2. 对于外连接 来说，由于驱动表中的记录即使在被驱动表中找不到符合 ON 子句连接条件的记录，所以此时驱动表和被驱动表 的关系就很重要了，也就是说**左外连接和右外连接的驱动表和被驱动表不能轻易互换。**

## 连接的原理

对于连接、内连接、外连接这些概念我们直接跳过下面我们主要来介绍连接的原理，为什么有的连接查的这么快，有的这么慢

## 嵌套循环连接（Nested-Loop Join）

对于两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍，具体访问几遍取 决于`对驱动表执行单表查询后的结果集中的记录条数`。对于内连接来说，选取哪个表为驱动表都没关系，而外连 接的驱动表是固定的，也就是说左（外）连接的驱动表就是左边的那个表，右（外）连接的驱动表就是右边的那 个表。

我们上边已经大致介绍过 t1 表和 t2 表执行内连接查询的大致过程，我们温习一下：

步骤1：选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表 查询。

步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。

![image-20220918220050295](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220918220050295.png)

如果有3个表进行连接的话，那么 步骤2 中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表， 重复上边过程，也就是 步骤2 中得到的结果集中的每一条记录都需要到 t3 表中找一找有没有匹配的记录，用伪 代码表示一下这个过程就是这样：

```java
for each row in t1 { #此处表示遍历满足对t1单表查询结果集中的每一条记录
    for each row in t2 { #此处表示对于某条t1表的记录来说，遍历满足对t2单表查询结果集中的
        每一条记录
        for each row in t3 { #此处表示对于某条t1和t2表的记录组合来说，对t3表进行单表查询
            if row satisfies join conditions, send to client
        }
    }
}
```

这个过程就像是一个嵌套的循环，所以这种**驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于 对驱动表执行单表查询后的结果集中的记录条数**的连接执行方式称之为 嵌套循环连接 （ Nested-Loop Join ）， 这是最简单，也是最笨拙的一种连接查询算法

## 使用索引加快连接速度

回顾一下最开始介绍的 t1 表和 t2 表进行内连接的例子：

SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';

我们使用的其实是` 嵌套循环连接` 算法执行的连接查询，再把上边那个查询执行过程表拉下来给大家看一下：

![image-20220919091348707](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220919091348707.png)

查询驱动表 t1 后的结果集中有两条记录， 嵌套循环连接 算法需要对被驱动表查询2次：

当 t1.m1 = 2 时，去查询一遍 t2 表，对 t2 表的查询语句相当于：

```sql
SELECT * FROM t2 WHERE t2.m2 = 2 AND t2.n2 < 'd';
```

当 t1.m1 = 3 时，再去查询一遍 t2 表，此时对 t2 表的查询语句相当于：

```sql
SELECT * FROM t2 WHERE t2.m2 = 3 AND t2.n2 < 'd';
```

可以看到，原来的 t1.m1 = t2.m2 这个涉及两个表的过滤条件在针对 t2 表做查询时关于 t1 表的条件就已经确 定了，所以我们只需要单单优化对 t2 表的查询了，上述两个对 t2 表的查询语句中利用到的列是 m2 和 n2 列， 我们可以：

- 在 m2 列上建立索引，因为对 m2 列的条件是等值查找，比如 t2.m2 = 2 、 t2.m2 = 3 等，所以可能使用到ref 的访问方法，假设使用 ref 的访问方法去执行对 t2 表的查询的话，需要回表之后再判断 t2.n2 < d 这个条件是否成立。

- 这里有一个比较特殊的情况，就是假设 m2 列是 t2 表的主键或者唯一二级索引列，那么使用 t2.m2 = 常数值 这样的条件从 t2 表中查找记录的过程的代价就是常数级别的。我们知道在单表中使用主键值或者唯一二级索引列的值进行等值查找的方式称之为 const ，而设计 MySQL 的大叔把在连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式称之为： eq_ref 。

- 在 n2 列上建立索引，涉及到的条件是 t2.n2 < 'd' ，可能用到 range 的访问方法，假设使用 range 的访问方法对 t2 表的查询的话，需要回表之后再判断在 m2 列上的条件是否成立。

假设 m2 和 n2 列上都存在索引的话，那么就需要从这两个里边儿挑一个代价更低的去执行对 t2 表的查询。当 然，建立了索引不一定使用索引，只有在 二级索引 + 回表 的代价比全表扫描的代价更低时才会使用索引。 另外，有时候连接查询的查询列表和过滤条件中可能只涉及被驱动表的部分列，而这些列都是某个索引的一部 分，这种情况下即使不能使用` eq_ref 、 ref 、 ref_or_null `或者 `range `这些访问方法执行对被驱动表的查询的 话，也可以使用索引扫描，也就是 `index `的访问方法来查询被驱动表。所以我们建议在真实工作中最好不要使 用 * 作为查询列表，最好把真实用到的列作为查询列表。

## 基于块的嵌套循环连接（Block Nested-Loop Join）

扫描一个表的过程其实是先把这个表从磁盘上加载到内存中，然后从内存中比较匹配条件是否满足。现实生活中 的表可不像 t1 、 t2 这种只有3条记录，成千上万条记录都是少的，几百万、几千万甚至几亿条记录的表到处都 是。内存里可能并不能完全存放的下表中所有的记录，所以在扫描表前边记录的时候后边的记录可能还在磁盘 上，等扫描到后边记录的时候可能内存不足，所以需要把前边的记录从内存中释放掉。我们前边又说过，采用 嵌 套循环连接 算法的两表连接过程中，被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特别多而且不 能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，这个 I/O 代价就非常大了，所以我们得想办法： **尽量减少访问被驱动表的次数**

当被驱动表中的数据非常多时，每次访问被驱动表，被驱动表的记录会被加载到内存中，在内存中的每一条记录 只会和驱动表结果集的一条记录做匹配，之后就会被从内存中清除掉。然后再从驱动表结果集中拿出另一条记 录，再一次把被驱动表的记录加载到内存中一遍，周而复始，驱动表结果集中有多少条记录，就得把被驱动表从 磁盘上加载到内存中多少次。所以我们可不可以**在把被驱动表的记录加载到内存的时候**，**一次性和多条驱动表中 的记录做匹配**，这样就可以大大减少重复从磁盘上加载被驱动表的代价了。所以设计 MySQL 的大叔提出了一个` join buffer `的概念，` join buffer` 就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集 中的记录装在这个` join buffer` 中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和 `join buffer` 中的 多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的 I/O 代价。使 用 join buffer 的过程如下图所示：

![image-20220919092025559](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220919092025559.png)

最好的情况是` join buffer `足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完 成连接操作了。设计 MySQL 的大叔把这种加入了 `join buffer `的嵌套循环连接算法称之为 **基于块的嵌套连接 （Block Nested-Loop Join）算法。**

这个 `join buffer` 的大小是可以通过启动参数或者系统变量 `join_buffer_size` 进行配置，默认大小为 262144字 节 （也就是 256KB ），最小可以设置为` 128字节` 。当然，对于优化被驱动表的查询来说，最好是为被驱动表加 上效率高的索引，如果实在不能使用索引，并且自己的机器的内存也比较大可以尝试调大`join_buffer_size` 的 值来对连接查询进行优化。 

另外需要注意的是，驱动表的记录并不是所有列都会被放到 `join buffer `中，只有查询列表中的列和过滤条件中 的列才会被放到` join buffer `中，所以再次提醒我们，最好不要把 * 作为查询列表，只需要把我们关心的列放到 查询列表就好了，这样还可以在` join buffer` 中放置更多的记录呢哈。































