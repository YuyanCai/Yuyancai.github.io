---
title: SpringCloud中级
---
## 一、Gateway

### 1.1 GateWay是什么

https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/

Cloud全家桶中有个很重要的组件就是网关，在1.x版本中都是采用的Zuul网关;

但在2.x版本中，zuul的升级一直跳票，SpringCloud最后自己研发了一个网关替代Zuul，那就是SpringCloud Gateway—句话：gateway是原zuul1.x版的替代

![img](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/54b61d819aa1630bc61732de340b55b4.png)



Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和Project Reactor等技术。

Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能，例如:熔断、限流、重试等。

SpringCloud Gateway是Spring Cloud的一个全新项目，基于Spring 5.0+Spring Boot 2.0和Project Reactor等技术开发的网关，它旨在为微服务架构提供—种简单有效的统一的API路由管理方式。

SpringCloud Gateway作为Spring Cloud 生态系统中的网关，目标是替代Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 1.x非Reactor模式的老版本。而为了提升网关的性能，**SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。**

Spring Cloud Gateway的目标提供统一的路由方式且基于 Filter链的方式提供了网关基本的功能，例如:安全，监控/指标，和限流。



**作用**

- 方向代理
- 鉴权
- 流量控制
- 熔断
- 日志监控
- …



**微服务架构中网关的位置**

![image-20220325093736472](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220325093736472.png)



### 1.2 GateWay非阻塞异步模型

**一、SpringCloud Gateway具有如下特性**

1. 基于Spring Framework 5，Project Reactor和Spring Boot 2.0进行构建；
2. 动态路由：能够匹配任何请求属性；
3. 可以对路由指定Predicate (断言)和Filter(过滤器)；
4. 集成Hystrix的断路器功能；
5. 集成Spring Cloud 服务发现功能；
6. 易于编写的Predicate (断言)和Filter (过滤器)
7. 请求限流功能；
8. 支持路径重写。



**二、SpringCloud Gateway与Zuul的区别**

1. 在SpringCloud Finchley正式版之前，Spring Cloud推荐的网关是Netflix提供的Zuul。
2. Zuul 1.x，是一个基于阻塞I/O的API Gateway。
3. Zuul 1.x基于Servlet 2.5使用阻塞架构它不支持任何长连接(如WebSocket)Zuul的设计模式和Nginx较像，每次I/О操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx用C++实现，Zuul用Java实现，而JVM本身会有第-次加载较慢的情况，使得Zuul的性能相对较差。
4. Zuul 2.x理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前还没有整合。Zuul .x的性能较Zuul 1.x有较大提升。在性能方面，根据官方提供的基准测试,Spring Cloud Gateway的RPS(每秒请求数)是Zuul的1.6倍。
5. Spring Cloud Gateway建立在Spring Framework 5、Project Reactor和Spring Boot2之上，使用非阻塞API。
6. Spring Cloud Gateway还支持WebSocket，并且与Spring紧密集成拥有更好的开发体验





**三、Zuul1.x模型**

Springcloud中所集成的Zuul版本，采用的是Tomcat容器，使用的是传统的Serviet IO处理模型。

Servlet的生命周期？servlet由servlet container进行生命周期管理。

1. container启动时构造servlet对象并调用servlet init()进行初始化；
2. container运行时接受请求，并为每个请求分配一个线程（一般从线程池中获取空闲线程）然后调用service)；
3. container关闭时调用servlet destory()销毁servlet。

![image-20220325094008173](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220325094008173.png)

上述模式的缺点：

**Servlet是一个简单的网络IO模型，当请求进入Servlet container时，Servlet container就会为其绑定一个线程，在并发不高的场景下这种模型是适用的。**但是一旦高并发(如抽风用Jmeter压)，线程数量就会上涨，而线程资源代价是昂贵的（上线文切换，内存消耗大）严重影响请求的处理时间。**在一些简单业务场景下，不希望为每个request分配一个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场景下servlet模型没有优势。**

**所以Zuul 1.X是基于servlet之上的一个阻塞式处理模型**，即Spring实现了处理所有request请求的一个servlet (DispatcherServlet)并由该servlet阻塞式处理处理。**所以SpringCloud Zuul无法摆脱servlet模型的弊端。**



**四、Gateway模型**

> Spring Cloud Gateway requires the Netty runtime provided by Spring Boot and Spring Webflux. It does not work in a traditional Servlet Container or when built as a WAR.

传统的Web框架，比如说: Struts2，SpringMVC等都是基于Servlet APl与Servlet容器基础之上运行的。

但是在Servlet3.1之后有了异步非阻塞的支持。而WebFlux是一个典型非阻塞异步的框架，它的核心是基于Reactor的相关API实现的。相对于传统的web框架来说，它可以运行在诸如Netty，Undertow及支持Servlet3.1的容器上。非阻塞式+函数式编程(Spring 5必须让你使用Java 8)。

Spring WebFlux是Spring 5.0 引入的新的响应式框架，区别于Spring MVC，它不需要依赖Servlet APl，它是完全异步非阻塞的，并且基于Reactor来实现响应式流规范。



### 1.3 Gateway工作流程

> **‎客户端向Spring Cloud Gateway发出请求。如果网关处理程序映射确定请求与路由匹配，则会将其发送到网关 Web 处理程序。此处理程序通过特定于请求的筛选器链运行请求。筛选器除以虚线的原因是筛选器可以在发送代理请求之前和之后运行逻辑。执行所有"预"筛选器逻辑。然后发出代理请求。发出代理请求后，将运行"post"筛选器逻辑。‎**

**三大核心概念**

1. Route(路由) - 路由是构建网关的基本模块,它由ID,目标URI,一系列的断言和过滤器组成,如断言为true则匹配该路由；
2. Predicate(断言) - 参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数),如果请求与断言相匹配则进行路由；
3. Filter(过滤) - 指的是Spring框架中GatewayFilter的实例,使用过滤器,可以在请求被路由前或者之后对请求进行修改。

![image-20220325094315553](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220325094315553.png)web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后，进行一些精细化控制。

**predicate就是我们的匹配条件；而fliter，就可以理解为一个无所不能的拦截器。有了这两个元素，再加上目标uri，就可以实现一个具体的路由了**

![image-20220325094427260](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220325094427260.png)



**客户端向Spring Cloud Gateway发出请求。然后在Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到GatewayWeb Handler。**

**Handler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。**

**过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(“pre”)或之后(“post"）执行业务逻辑。**

**Filter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。**

**核心逻辑：路由转发 + 执行过滤器链。**



### 1.4 Gateway9527搭建

1.新建Module - cloud-gateway-gateway9527

2.POM

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>cloud</artifactId>
        <groupId>com.caq.cloud</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>cloud-gateway-gateway9527</artifactId>
    <dependencies>
        <!--gateway-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
        <!--eureka-client-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->
        <dependency>
            <groupId>com.caq.cloud</groupId>
            <artifactId>cloud-api-commons</artifactId>
            <version>${project.version}</version>
        </dependency>
        <!--一般基础配置类-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>
```



3.主启动类

```java
package com.caq.cloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class EurekaMain7001 {
    public static void main(String[] args) {
        SpringApplication.run(EurekaMain7001.class,args);
    }
}
```





4.9527网关如何做路由映射?

cloud-provider-payment8001看看controller的访问地址

- get
- lb

我们目前不想暴露8001端口，希望在8001外面套一层9527



5.YML新增网关配置

```yml
server:
  port: 9527

spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      routes:
        - id: payment_routh ##payment_route    ##路由的ID，没有固定规则但要求唯一，建议配合服务名
          uri: http://localhost:8001          ##匹配后提供服务的路由地址
          predicates:
            - Path=/payment/get/**         ## 断言，路径相匹配的进行路由

        - id: payment_routh2 ##payment_route    ##路由的ID，没有固定规则但要求唯一，建议配合服务名
          uri: http://localhost:8001          ##匹配后提供服务的路由地址
          predicates:
            - Path=/payment/lb/**         ## 断言，路径相匹配的进行路由

eureka:
  instance:
    hostname: cloud-gateway-service
  client: ##服务提供者provider注册进eureka服务列表内
    service-url:
      register-with-eureka: true
      fetch-registry: true
      defaultZone: http://eureka7001.com:7001/eureka

```



6.测试

启动7001

启动8001-cloud-provider-payment8001

启动9527网关

访问说明

添加网关前 - http://localhost:8001/payment/get/1
添加网关后 - http://localhost:9527/payment/get/1
两者访问成功，返回相同结果

![](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220325100604521.png)





### 1.5 Gateway配置路由的两种方式

写配置类的方式配置路由

```java
package com.caq.cloud.config;

import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GateWayConfig {
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder) {
        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();

        routes.route("path_route_caq",
                r -> r.path("/guonei")
                        .uri("http://news.baidu.com/guonei")).build();
        return routes.build();
    }
}
```



![image-20220325103050027](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220325103050027.png)





### 1.6 GateWay配置动态路由

> locator
> n. 定位器，探测器

默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建**动态路由进行转发，从而实现动态路由的功能**（不写死一个地址）。



**启动**

- eureka7001
- payment8001/8002



**YML**

需要注意的是uri的协议为lb，表示启用Gateway的负载均衡功能。

lb://serviceName是spring cloud gateway在微服务中自动为我们创建的负载均衡uri。

```yml
server:
  port: 9527

spring:
  application:
    name: cloud-gateway
#############################新增网关配置###########################
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true ##开启从注册中心动态创建路由的功能，利用微服务名进行路由
      routes:
        - id: payment_routh ##payment_route    ##路由的ID，没有固定规则但要求唯一，建议配合服务名
          ##uri: http://localhost:8001          ##匹配后提供服务的路由地址
          uri: lb://cloud-payment-service ##匹配后提供服务的路由地址
          predicates:
            - Path=/payment/get/**         ## 断言，路径相匹配的进行路由

        - id: payment_routh2 ##payment_route    ##路由的ID，没有固定规则但要求唯一，建议配合服务名
          ##uri: http://localhost:8001          ##匹配后提供服务的路由地址
          uri: lb://cloud-payment-service ##匹配后提供服务的路由地址
          predicates:
            - Path=/payment/lb/**         ## 断言，路径相匹配的进行路由
####################################################################

eureka:
  instance:
    hostname: cloud-gateway-service
  client: ##服务提供者provider注册进eureka服务列表内
    service-url:
      register-with-eureka: true
      fetch-registry: true
      defaultZone: http://eureka7001.com:7001/eureka

```



**测试**

浏览器输入 - http://localhost:9527/payment/lb



![image-20220325162522438](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220325162522438.png)

![image-20220325162532222](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220325162532222.png)

### 1.7 GateWay常用的Predicate

> **predicate**
>
> 美: ['predɪkeɪt] 英: ['predɪkət]
>
> **v.** 断言；使基于；使以…为依据；表明
>
> **adj.** 述语的；谓项的
>
> **n.** 谓语（句子成分，对主语加以陈述，如 John went home 中的 went home）

[官方文档](https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/##gateway-request-predicates-factories)

Spring Cloud Gateway将路由匹配作为Spring WebFlux HandlerMapping基础架构的一部分。

Spring Cloud Gateway包括许多内置的Route Predicate工厂。所有这些Predicate都与HTTP请求的不同属性匹配。多个RoutePredicate工厂可以进行组合。

Spring Cloud Gateway创建Route 对象时，使用RoutePredicateFactory 创建 Predicate对象，Predicate 对象可以赋值给Route。Spring Cloud Gateway包含许多内置的Route Predicate Factories。
所有这些谓词都匹配HTTP请求的不同属性。多种谓词工厂可以组合，并通过逻辑and。

常用的Route Predicate Factory

1. The After Route Predicate Factory
2. The Before Route Predicate Factory
3. The Between Route Predicate Factory
4. The Cookie Route Predicate Factory
5. The Header Route Predicate Factory
6. The Host Route Predicate Factory
7. The Method Route Predicate Factory
8. The Path Route Predicate Factory
9. The Query Route Predicate Factory
10. The RemoteAddr Route Predicate Factory
11. The weight Route Predicate Factory



**The After Route Predicate Factory**

```yml
spring:
  cloud:
    gateway:
      routes:
      - id: after_route
        uri: https://example.org
        predicates:
        ## 这个时间后才能起效
        - After=2017-01-20T17:42:47.789-07:00[America/Denver]
```



**The Between Route Predicate Factory**

```yml
spring:
  cloud:
    gateway:
      routes:
      - id: between_route
        uri: https://example.org
        ## 两个时间点之间
        predicates:
        - Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver]
```



**The Cookie Route Predicate Factory**

```yml
spring:
  cloud:
    gateway:
      routes:
      - id: cookie_route
        uri: https://example.org
        predicates:
        - Cookie=chocolate, ch.p
```



测试

```
## 该命令相当于发get请求，且没带cookie

curl http://localhost:9527/payment/lb

## 带cookie的

curl http://localhost:9527/payment/lb --cookie "chocolate=chip"
```



**The Header Route Predicate Factory**

```yml
spring:
  cloud:
    gateway:
      routes:
      - id: header_route
        uri: https://example.org
        predicates:
        - Header=X-Request-Id, \d+
```

测试

```apl
## 带指定请求头的参数的CURL命令

curl http://localhost:9527/payment/lb -H "X-Request-Id:123
```

.....................



**总结**

Predicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理。



### 1.8 GateWay的Filter

路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。Spring Cloud Gateway内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生。



Spring Cloud Gateway的Filter:



**生命周期：**

1. pre
2. post



**种类（具体看官方文档）：**

1. GatewayFilter - 有31种
2. GlobalFilter - 有10种



常用的GatewayFilter：AddRequestParameter GatewayFilter

自定义全局GlobalFilter：

**两个主要接口介绍：**

1. GlobalFilter
2. Ordered



**能干什么：**

1. 全局日志记录
2. 统一网关鉴权

…



```java
package com.caq.cloud.filter;

import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.util.Date;

@Component
@Slf4j
public class MyLogGateWayFilter implements GlobalFilter, Ordered
{

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain)
    {
        log.info("***********come in MyLogGateWayFilter:  "+new Date());

        String uname = exchange.getRequest().getQueryParams().getFirst("uname");

        if(uname == null)
        {
            log.info("*******用户名为null，非法用户，o(╥﹏╥)o");
            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);
            return exchange.getResponse().setComplete();
        }

        return chain.filter(exchange);
    }

    @Override
    public int getOrder()
    {
        return 0;
    }
}
```



**测试**

启动：

- EurekaMain7001
- PaymentMain8001
- GateWayMain9527
- PaymentMain8002

浏览器输入：

- http://localhost:9527/payment/lb - 反问异常
- http://localhost:9527/payment/lb?uname=abc - 正常反问
  

![image-20220326095042658](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220326095042658.png)

![image-20220326095108670](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220326095108670.png)

![image-20220326095125330](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220326095125330.png)



## 二、Config分布式配置中心

分布式系统面临的配置问题

微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。

SpringCloud提供了ConfigServer来解决这个问题


**是什么**

![image-20220326103857494](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220326103857494.png)

SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。



**怎么玩**

SpringCloud Config分为**服务端**和**客户端**两部分。

- 服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口。
- 客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。



**能干嘛**

- 集中管理配置文件
- 不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release
- 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息
- 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置
- 将配置信息以REST接口的形式暴露 - post/crul访问刷新即可…
  



**与GitHub整合配置**

由于SpringCloud Config默认使用Git来存储配置文件(也有其它方式,比如支持SVN和本地文件)，但最推荐的还是Git，而且使用的是http/https访问的形式。



### 2.1 Config配置总控中心

本地创建工作目录（空文件夹），通过gitbash克隆github仓库

编写三个配置文件

![image-20220326143335728](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220326143335728.png)



在springcloud-config的文件夹种创建三个配置文件随后

git add .

git commit -m "test"

git push origin "master"



配置文件如下所示：

config-dev.yml

```yml
config:
  info: "master branch,springcloud-config/config-dev.yml version=7"
```



config-prod.yml

```yml
config:
  info: "master branch,springcloud-config/config-prod.yml version=1"
```



config-test.yml

```yml
config:
  info: "master branch,springcloud-config/config-test.yml version=1" 
```



push之后的仓库如下：

![image-20220327104258478](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220327104258478.png)



新建Module模块cloud-config-center-3344，它即为Cloud的配置中心模块CloudConfig Center

**1、建模块**

**2、改pom**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>cloud</artifactId>
        <groupId>com.caq.cloud</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>cloud-config-center-3344</artifactId>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-config-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>
```





**3、yml**

```yml
server:
  port: 3344

spring:
  application:
    name:  cloud-config-center ##注册进Eureka服务器的微服务名
  cloud:
    config:
      server:
        git:
          uri: https://gitee.com/cai-yuyan/springcloud-config.git
          ####搜索目录
          search-paths:
            - springcloud-config
      ####读取分支
      label: master

##服务注册到eureka地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka
```



**4、主启动**

```java
package com.caq.cloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.server.EnableConfigServer;

@SpringBootApplication
@EnableConfigServer
public class ConfigCenterMain3344
{
    public static void main(String[] args) {
        SpringApplication.run(ConfigCenterMain3344.class, args);
    }
}
```





windows下修改hosts文件，增加映射

127.0.0.1 config-3344.com



测试通过Config微服务是否可以从GitHub上获取配置内容

启动ConfigCenterMain3344

浏览器防问 - http://config-3344.com:3344/master/config-dev.yml



**5、测试**

![image-20220327104242367](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220327104242367.png)



**配置读取规则**



/{label}/{application}-{profile}.yml（推荐）

master分支
http://config-3344.com:3344/master/config-dev.yml
http://config-3344.com:3344/master/config-test.yml
http://config-3344.com:3344/master/config-prod.yml

dev分支
http://config-3344.com:3344/dev/config-dev.yml
http://config-3344.com:3344/dev/config-test.yml
http://config-3344.com:3344/dev/config-prod.yml



/{application}-{profile}.yml

http://config-3344.com:3344/config-dev.yml
http://config-3344.com:3344/config-test.yml
http://config-3344.com:3344/config-prod.yml
http://config-3344.com:3344/config-xxxx.yml(不存在的配置)
/{application}/{profile}[/{label}]

http://config-3344.com:3344/config/dev/master
http://config-3344.com:3344/config/test/master
http://config-3344.com:3344/config/test/dev

重要配置细节总结

/{name}-{profiles}.yml
/{label}-{name}-{profiles}.yml
label：分支(branch)
name：服务名
profiles：环境(dev/test/prod)
成功实现了用SpringCloud Config通过gitee获取配置信息



### 2.2 Config客户端配置与测试

**1、新建cloud-config-client-3355**

**2、POM**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>cloud</artifactId>
        <groupId>com.caq.cloud</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>cloud-config-client-3355</artifactId>

    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-config</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>
```



> 什么是bootstrap.yml？
>
> applicaiton.yml是用户级的资源配置项
>
> **bootstrap.yml是系统级的，优先级更加高**
>
> boostrap.yml主要负责将外部源加载配置属性解析配置。之后在和本地的application.yml结合成完成的配置文件
>
> 
>
> 初始化的时候，BootstrapContext负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的Environment。
>
> Bootstrap属性有高优先级，默认情况下，它们不会被本地配置覆盖。Bootstrap context和Application Context有着不同的约定，所以新增了一个bootstrap.yml文件，保证Bootstrap Context和Application Context配置的分离。
>
> 要将Client模块下的application.yml文件改为bootstrap.yml,这是很关键的，因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml。



**3、YML**

```yml
server:
  port: 3355

spring:
  application:
    name: config-client
  cloud:
    ##Config客户端配置
    config:
      label: master ##分支名称
      name: config ##配置文件名称
      profile: dev ##读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml
      uri: http://localhost:3344 ##配置中心地址


##服务注册到eureka地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka
```



**4、启动类**

```java
package com.caq.cloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@EnableEurekaClient
@SpringBootApplication
public class ConfigClientMain3355
{
    public static void main(String[] args) {
        SpringApplication.run(ConfigClientMain3355.class, args);
    }
}
```



**5、业务类**

```java
package com.caq.cloud.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RefreshScope
public class ConfigClientController
{
    @Value("${config.info}")
    private String configInfo;

    @GetMapping("/configInfo")
    public String getConfigInfo()
    {
        return configInfo;
    }
}
```



**6、测试**

> 启动Config配置中心3344微服务并自测
>
> http://config-3344.com:3344/master/config-prod.yml
> http://config-3344.com:3344/master/config-dev.yml
> 启动3355作为Client准备访问
>
> http://localhost:3355/configlnfo

![image-20220327140337133](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220327140337133.png)





**7、遗留的问题，每次修改配置文件都需要重启微服务吗**



### 2.3 Config动态刷新之手动版

避免每次更新配置都要重启客户端微服务3355

**动态刷新步骤**：

1、修改3355模块

2、POM引入actuator监控

```java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

3、修改YML，添加暴露监控端口配置

```yml
## 暴露监控端点
management:
  endpoints:
    web:
      exposure:
        include: "*"
```

4、测试

![image-20220327142427432](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220327142427432.png)

5、手动解决客户端的同步问题

curl -X POST "http://localhost:3355/actuator/refresh"

![image-20220327142635997](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220327142635997.png)





## 三、Bus消息总线

### 3.1 Bus消息总线简介

> 快速复习：
>
> [RabbitMQ快速入门_小蜗牛耶的博客-CSDN博客](https://blog.csdn.net/qq_45714272/article/details/123527590?spm=1001.2014.3001.5502)



**什么是bus消息总线？**

分布式自动刷新配置功能

Spring Cloud Bus配合Spring Cloud Config使用可以实现配置的动态刷新。



**能干嘛**

Spring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。

![image-20220327153019417](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220327153019417.png)





**为何被称为总线**

什么是总线

**在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。**



==基本原理==

**ConfigClient实例都监听MQ中同一个topic(默认是Spring Cloud Bus)。当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其它监听同一Topic的服务就能得到通知，然后去更新自身的配置。**



**启动rabbitmq**

![image-20220327151209291](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220327151209291.png)





### 3.2 Bus动态刷新全局广播的设计思想和选型

演示广播效果，增加复杂度，再以3355为模板再制作一个3366

1.新建cloud-config-client-3366

2.POM

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>cloud</artifactId>
        <groupId>com.caq.cloud</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>cloud-config-client-3366</artifactId>

    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-config</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>
```



3.YML

```yml
server:
  port: 3366

spring:
  application:
    name: config-client
  cloud:
    ##Config客户端配置
    config:
      label: master ##分支名称
      name: config ##配置文件名称
      profile: dev ##读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml
      uri: http://localhost:3344 ##配置中心地址

##rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口
  rabbitmq:
    host: 192.168.10.10
    port: 5672
    username: admin
    password: 123

##服务注册到eureka地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka

## 暴露监控端点
management:
  endpoints:
    web:
      exposure:
        include: "*"
```



4.主启动

```java
package com.caq.cloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@EnableEurekaClient
@SpringBootApplication
public class ConfigClientMain3366
{
    public static void main(String[] args)
    {
        SpringApplication.run(ConfigClientMain3366.class,args);
    }
}
```



5.业务类

```java
package com.caq.cloud.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RefreshScope
public class ConfigClientController
{
    /**
     *  @Value注解的作用就是读取外部配置文件的内容
     *  比如：server:
     *          port: 3366
     *  那么@Value("${server.port}")的值就是3366
     */
    @Value("${server.port}")
    private String serverPort;

    @Value("${config.info}")
    private String configInfo;

    @GetMapping("/configInfo")
    public String configInfo()
    {
        return "serverPort: "+serverPort+"\t\n\n configInfo: "+configInfo;
    }

}
```



**设计思想**

1.利用消息总线触发一个客户端/bus/refresh,而刷新所有客户端的配置

![image-20220327155259756](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220327155259756.png)



2.利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置

![image-20220327155316640](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220327155316640.png)



图二的架构显然更加适合，图—不适合的原因如下：

**打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。**

**破坏了微服务各节点的对等性。**



**有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改。**







### 3.3 Bus动态刷新全局广播配置实现

#### 3.3.1 cloud-config-center-3344

**1、给cloud-config-center-3344配置中心服务端添加消息总线支持**

2、POM

```xml
<!--添加消息总线RabbitNQ支持-->
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-bus-amqp</artifactId>
</dependency>
<dependency>
	<groupId>org-springframework.boot</groupId>
	<artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

3、YML

```yml
server:
  port: 3344

spring:
  application:
    name: cloud-config-center ##注册进Eureka服务器的微服务名
  cloud:
    config:
      server:
        git:
          uri: https://gitee.com/cai-yuyan/springcloud-config.git ##GitHub上面的git仓库名字
          ####搜索目录
          search-paths:
            - springcloud-config
      ####读取分支
      label: master

  rabbitmq:
    host: 192.168.10.10
    port: 5672
    username: admin
    password: 123

##服务注册到eureka地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka

###rabbitmq相关配置,暴露bus刷新配置的端点<--------------------------
management:
  endpoints: ##暴露bus刷新配置的端点
    web:
      exposure:
        include: 'bus-refresh'
```



#### 3.3.2 cloud-config-client-3355

**1、给cloud-config-client-3355客户端添加消息总线支持**

2、POM

```xml
<!--添加消息总线RabbitNQ支持-->
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-bus-amqp</artifactId>
</dependency>
<dependency>
	<groupId>org-springframework.boot</groupId>
	<artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```



3、YML

```yml
server:
  port: 3355

spring:
  application:
    name: config-client
  cloud:
    ##Config客户端配置
    config:
      label: master ##分支名称
      name: config ##配置文件名称
      profile: dev ##读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml
      uri: http://localhost:3344 ##配置中心地址

  ##rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口<----------------------
  rabbitmq:
    host: 192.168.10.10
    port: 5672
    username: admin
    password: 123


##服务注册到eureka地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka

## 暴露监控端点
management:
  endpoints:
    web:
      exposure:
        include: "*"
```



#### 3.3.3 cloud-config-client-3366

**1、给cloud-config-client-3366客户端添加消息总线支持**

2、POM

```xml
<!--添加消息总线RabbitNQ支持-->
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-bus-amqp</artifactId>
</dependency>
<dependency>
	<groupId>org-springframework.boot</groupId>
	<artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

3、YML

```yml
server:
  port: 3366

spring:
  application:
    name: config-client
  cloud:
    ##Config客户端配置
    config:
      label: master ##分支名称
      name: config ##配置文件名称
      profile: dev ##读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml
      uri: http://localhost:3344 ##配置中心地址

  ##rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口
  rabbitmq:
    host: 192.168.10.10
    port: 5672
    username: admin
    password: 123

##服务注册到eureka地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka

## 暴露监控端点
management:
  endpoints:
    web:
      exposure:
        include: "*"
```



#### 3.3.4 测试

- 启动
  - EurekaMain7001
  - ConfigcenterMain3344
  - ConfigclientMain3355
  - ConfigclicntMain3366

![image-20220327170014745](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220327170014745.png)



- 修改gitee上配置文件内容，增加版本号
- ![image-20220327170222226](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220327170222226.png)
- 发送POST请求
  - `curl -X POST "http://localhost:3344/actuator/bus-refresh"`
  - **—次发送，处处生效**



![image-20220327170711699](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220327170711699.png)



- 配置中心
  - http://config-3344.com:3344/config-dev.yml
- 客户端
  - http://localhost:3355/configlnfo
  - http://localhost:3366/configInfo
  - 获取配置信息，发现都已经刷新了

**—次修改，广播通知，处处生效**



### 3.4 Bus动态刷新定点通知

> 定点通知就是只通知某个，而不是全部

不想全部通知，只想定点通知

- 只通知3355
- 不通知3366

公式：http://localhost:3344/actuator/bus-refresh/{destination}

/bus/refresh请求不再发送到具体的服务实例上，而是发给config server通过destination参数类指定需要更新配置的服务或实例



实例

- 我们只通知3355，不通知3366

- `curl -X POST "http://localhost:3344/actuator/bus-refresh/config-client:3355`



测试

![image-20220327192252326](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220327192252326.png)







## 四、Stream

### 4.1 Stream简介

常见MQ(消息中间件)：

- ActiveMQ
- RabbitMQ
- RocketMQ
- Kafka

有没有一种新的技术诞生，让我们不再关注具体MQ的细节，我们只需要用一种适配绑定的方式，自动的给我们在各种MQ内切换。（类似于Hibernate）

Cloud Stream是什么？屏蔽底层消息中间件的差异，降低切换成本，统一消息的**编程模型。**



**什么是Spring Cloud Stream？**

官方定义Spring Cloud Stream是一个构建消息驱动微服务的框架。

应用程序通过inputs或者 outputs 来与Spring Cloud Stream中binder对象交互。

通过我们配置来binding(绑定)，而Spring Cloud Stream 的binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式。

通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。
Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。

目前仅支持RabbitMQ、 Kafka。



### 4.2 Stream的设计思想

**标准MQ**

![image-20220328094950428](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328094950428.png)

生产者/消费者之间靠消息媒介传递信息内容
消息必须走特定的通道 - 消息通道 Message Channel
消息通道里的消息如何被消费呢，谁负责收发处理 - 消息通道MessageChannel的子接口SubscribableChannel，由MessageHandler消息处理器所订阅。

**为什么用Cloud Stream？**

比方说我们用到了RabbitMQ和Kafka，由于这两个消息中间件的架构上的不同，像RabbitMQ有exchange，kafka有Topic和Partitions分区。

![image-20220328095126768](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328095126768.png)



这些中间件的差异性导致我们实际项目开发给我们造成了一定的困扰，我们如果用了两个消息队列的其中一种，后面的业务需求，我想往另外一种消息队列进行迁移，这时候无疑就是一个灾难性的，一大堆东西都要重新推倒重新做，因为它跟我们的系统耦合了，这时候Spring Cloud Stream给我们提供了—种解耦合的方式。


**Stream凭什么可以统一底层差异？**

在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行信息交互的时候，由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件细节之间的隔离。通过向应用程序暴露统一的Channel通道，使得应用程序不需要再考虑各种不同的消息中间件实现。

**通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离**



**Binder**：

- INPUT对应于消费者
- OUTPUT对应于生产者



![image-20220328095720991](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328095720991.png)



**Stream中的消息通信方式遵循了发布-订阅模式**

Topic主题进行广播

- 在RabbitMQ就是Exchange
- 在Kakfa中就是Topic



### 4.3 Stream编码常用注解

**Spring Cloud Stream标准流程套路**

![image-20220328095927495](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328095927495.png)

![image-20220328095935746](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328095935746.png)



Binder - 很方便的连接中间件，屏蔽差异。

Channel - 通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel对队列进行配置。

Source和Sink - 简单的可理解为参照对象是Spring Cloud Stream自身，从Stream发布消息就是输出，接受消息就是输入。



**编码API和常用注解**

| 组成            | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| Middleware      | 中间件，目前只支持RabbitMQ和Kafka                            |
| Binder          | Binder是应用与消息中间件之间的封装，目前实行了Kafka和RabbitMQ的Binder，通过Binder可以很方便的连接中间件，可以动态的改变消息类型(对应于Kafka的topic,RabbitMQ的exchange)，这些都可以通过配置文件来实现 |
| @Input          | 注解标识输入通道，通过该输乎通道接收到的消息进入应用程序     |
| @Output         | 注解标识输出通道，发布的消息将通过该通道离开应用程序         |
| @StreamListener | 监听队列，用于消费者的队列的消息接收                         |
| @EnableBinding  | 指信道channel和exchange绑定在一起                            |



**实例**

工程中新建三个子模块

cloud-stream-rabbitmq-provider8801，作为生产者进行发消息模块
cloud-stream-rabbitmq-consumer8802，作为消息接收模块
cloud-stream-rabbitmq-consumer8803，作为消息接收模块



### 4.4 示例



#### 4.4.1 Stream消息驱动之生产者

新建Module：cloud-stream-rabbitmq-provider8801

POM

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>cloud</artifactId>
        <groupId>com.caq.cloud</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>cloud-stream-rabbitmq-provider8801</artifactId>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-stream-rabbit</artifactId>
        </dependency>
        <!--基础配置-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>
```

YML

```yml
server:
  port: 8801

spring:
  application:
    name: cloud-stream-provider
  cloud:
    stream:
      binders: ## 在此处配置要绑定的rabbitmq的服务信息；
        defaultRabbit: ## 表示定义的名称，用于于binding整合
          type: rabbit ## 消息组件类型
          environment: ## 设置rabbitmq的相关的环境配置
            spring:
              rabbitmq:
                host: 192.168.10.10
                port: 5672
                username: admin
                password: 123
      bindings: ## 服务的整合处理
        output: ## 这个名字是一个通道的名称
          destination: studyExchange ## 表示要使用的Exchange名称定义
          content-type: application/json ## 设置消息类型，本次为json，文本则设置“text/plain”
          binder: defaultRabbit ## 设置要绑定的消息服务的具体设置

eureka:
  client: ## 客户端进行Eureka注册的配置
    service-url:
      defaultZone: http://localhost:7001/eureka
  instance:
    lease-renewal-interval-in-seconds: 2 ## 设置心跳的时间间隔（默认是30秒）
    lease-expiration-duration-in-seconds: 5 ## 如果现在超过了5秒的间隔（默认是90秒）
    instance-id: send-8801.com  ## 在信息列表时显示主机名称
    prefer-ip-address: true     ## 访问的路径变为IP地址
```

主启动类StreamMQMain8801

```java
package com.caq.cloud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class StreamMQMain8801 {
    public static void main(String[] args) {
        SpringApplication.run(StreamMQMain8801.class,args);
    }
}
```

业务类

1.发送消息接口

```java
package com.caq.cloud.service;

public interface IMessageProvider {
    public String send();
}
```



2.发送消息接口实现类

```java
package com.caq.cloud.service.impl;

import com.caq.cloud.service.IMessageProvider;
import com.netflix.discovery.converters.Auto;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.support.MessageBuilder;

import javax.annotation.Resource;
import java.util.UUID;

@EnableBinding(Source.class)
@Slf4j
public class MessageProviderImpl implements IMessageProvider {

    @Resource
    private MessageChannel output;


    @Override
    public String send() {
        String serial = UUID.randomUUID().toString();
        output.send(MessageBuilder.withPayload(serial).build());
        log.info("******serial"+serial);
        return null;
    }
}
```



3.Controller

```java
package com.caq.cloud.controller;

import com.caq.cloud.service.IMessageProvider;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.Resource;

@RestController
public class SendMessageController {

    @Resource
    private IMessageProvider messageProvider;

    @GetMapping(value = "/sendMessage")
    public String sendMessage(){
        return messageProvider.send();
    }

}
```



4.测试

启动 7001eureka
启动 RabbitMq
启动 8801
访问 - http://localhost:8801/sendMessage
后台将打印serial: UUID字符串

![image-20220328102927928](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328102927928.png)



#### 4.4.2 Stream消息驱动之消费者

以下代码不在复制上去，下面以截图的形式截取关键代码,源代码会放在gitee上。

POM

同上



YML

由output变为input

![image-20220328110115441](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328110115441.png)



启动类

![image-20220328110212011](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328110212011.png)



业务类

![image-20220328110258098](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328110258098.png)





测试

![image-20220328105949744](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328105949744.png)

![image-20220328105958270](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328105958270.png)

![image-20220328110018489](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328110018489.png)





#### 4.4.3 分组消费与持久化

依照8802，克隆出来一份运行8803 - cloud-stream-rabbitmq-consumer8803。



**发送消息出现了两个问题**

1. 有重复消费问题
2. 消息持久化问题



**消费**

http://localhost:8801/sendMessage
目前是8802/8803同时都收到了，存在重复消费问题
==如何解决：分组和持久化属性group（重要）==



**重复消费行为：**

![image-20220328111301346](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328111301346.png)

![image-20220328111306956](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328111306956.png)

![image-20220328111315021](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328111315021.png)





> 我们复习下MQ的概念：
>
> ![image-20220328112311592](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328112311592.png)



从mq中可以看到，交换机绑定了两个队列。那就相当于是两个不同的组了，所以会重复消费

![image-20220328111240136](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328111240136.png)





#### 4.4.4 group解决消息重复消费

**原理**

微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次。

不同的组是可以重复消费的，同一个组内会发生竞争关系，只有其中一个可以消费。

保证两个消费者在同一group中

![image-20220328114120781](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328114120781.png)



**测试**

![image-20220328114235337](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328114235337.png)



![image-20220328114244420](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328114244420.png)

![image-20220328114250103](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328114250103.png)



### 4.4.5 Stream之消息持久化

过上述，解决了重复消费问题，再看看持久化。

**停止8802/8803并去除掉8802的分组group: A_Group，8803的分组group: A_Group没有去掉。**

8801先发送4条消息到RabbitMq。

先启动8802，无分组属性配置，后台没有打出来消息。

**再启动8803，有分组属性配置，后台打出来了MQ上的消息。(消息持久化体现)**



## 五、Sleuth

### 5.1 Sleuth是什么

> sleuth
> 英 [sluːθ] 美 [sluːθ]
> n. 侦探

**为什么会出现这个技术？要解决哪些问题？**

**客户端发起的请求在后端系统中会经过多个不同的服务节点来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。** 



- ==**Spring Cloud Sleuth提供了一套完整的服务跟踪的解决方案**==
- 在分布式系统中提供追踪解决方案并且兼容支持了==zipkin（监控平台）==



![image-20220328150201415](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328150201415.png)



下载zipkin的jar包，在windows端运行

**java -jar zipkin-server-2.12.9-exec.jar**

![image-20220328144226306](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328144226306.png)



**运行控制台**

http://localhost:9411/zipkin/

![image-20220328151227080](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328151227080.png)



**完整的调用链路**

表示一请求链路，一条链路通过Trace ld唯一标识，Span标识发起的请求信息，各span通过parent id关联起来



![image-20220328151259806](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328151259806.png)



—条链路通过Trace ld唯一标识，Span标识发起的请求信息，各span通过parent id关联起来。

![image-20220328151314820](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328151314820.png)

整个链路的依赖关系如下：

![image-20220328151325959](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328151325959.png)



名词解释

- Trace：类似于树结构的Span集合，表示一条调用链路，存在唯一标识
- span：表示调用链路来源，通俗的理解span就是一次请求信息





### 5.2 Sleuth链路监控展现

我们基于前面写的8001和80做测试

在原pom基础上添加如下依赖



8001：

```xml
<!--包含了sleuth+zipkin-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-zipkin</artifactId>
</dependency>
```



```yml
spring:
  application:
    name: cloud-payment-service

  zipkin: ##<-------------------------------------关键 
      base-url: http://localhost:9411
  sleuth: ##<-------------------------------------关键
    sampler:
    ##采样率值介于 0 到 1 之间，1 则表示全部采集
    probability: 1
```

​    



```java
@GetMapping("/payment/zipkin")
public String paymentZipkin() {
    return "hi ,i'am paymentzipkin server fall back，welcome to here, O(∩_∩)O哈哈~";
}
```



80：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-zipkin</artifactId>
</dependency>
```

YML

```yml
spring:
    application:
        name: cloud-order-service
    zipkin:
      base-url: http://localhost:9411
    sleuth:
      sampler:
        probability: 1
```

```java
    // ====================> zipkin+sleuth
    @GetMapping("/consumer/payment/zipkin")
    public String paymentZipkin()
    {
        String result = restTemplate.getForObject("http://localhost:8001"+"/payment/zipkin/", String.class);
        return result;
    }
}
```

依次启动eureka7001/8001/80 - 80调用8001几次测试下

![image-20220328153907003](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328153907003.png)

![image-20220328153924178](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328153924178.png)

![image-20220328154045132](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328154045132.png)

依赖关系

![image-20220328154057533](https://typora-1259403628.cos.ap-nanjing.myqcloud.com/image-20220328154057533.png)

























